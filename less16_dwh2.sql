DROP TABLE CHANGE.OPER_CHANGE_LOAD;
DROP TABLE CHANGE.OPER_CHANGE_LOAD_N;
DROP TABLE CHANGE.ETL_FILE_LOAD; 
DROP TABLE CHANGE.DDS_HUB_PRODUCT; 
DROP TABLE CHANGE.DDS_ST_PRODUCT_METRICS; 
DROP TABLE CHANGE.ETL_FILE_LOAD;
DROP TABLE CHANGE.ODS_OPER;



create schema CHANGE;

--0. Create ETL file metadata table

CREATE TABLE IF NOT EXISTS CHANGE.ETL_FILE_LOAD (
	FILE_ID AUTO_INCREMENT(1, 1, 1) NOT NULL,
	SOURCE VARCHAR(128) NOT NULL,
	FILE_NAME VARCHAR NOT NULL,
	BUSINESS_DT DATETIME NOT NULL,
	LOAD_TS TIMESTAMP NOT NULL,
	PRIMARY KEY (FILE_ID, SOURCE, FILE_NAME, BUSINESS_DT) ENABLED 
)
ORDER BY SOURCE, FILE_NAME, BUSINESS_DT 
UNSEGMENTED ALL NODES
;

-- 1  Create STAGE table  dirty data from  kafka and stream sets

CREATE TABLE IF NOT EXISTS CHANGE.OPER_CHANGE_LOAD (
	BRANCH VARCHAR  NOT NULL, 
	CURRENCY VARCHAR NOT NULL,
	AMOUNT INTEGER,
	TOTAL  NUMERIC(20,5),
	DATATIME VARCHAR  NOT NULL,
	BUSINESS_DT VARCHAR NOT NULL,
	NEW_FIELD NUMERIC(3,0)
) 
;

-- 2  Create STAGE table  dirty data from  kafka and stream sets  convert  format

CREATE TABLE IF NOT EXISTS CHANGE.OPER_CHANGE_LOAD_N (
	BRANCH VARCHAR  NOT NULL, 
	CURRENCY VARCHAR NOT NULL,
	AMOUNT INTEGER,
	TOTAL  NUMERIC(20,5),
	DATATIME DATETIME  NOT NULL,
	BUSINESS_DT DATETIME NOT NULL,
	NEW_FIELD NUMERIC(3,0),
	PRIMARY KEY (DATATIME, BRANCH)
) 
ORDER BY 
	DATATIME,
	BRANCH 
SEGMENTED BY HASH(DATATIME, BRANCH) ALL NODES
;

-- 3  inser conver data

INSERT INTO CHANGE.OPER_CHANGE_LOAD_N ( 
	BRANCH , 
	CURRENCY ,
	AMOUNT , 
	TOTAL , 
	DATATIME ,  
	BUSINESS_DT , 
	NEW_FIELD 
) 
SELECT 
	src.BRANCH , 
	src.CURRENCY ,
	src.AMOUNT , 
	src.TOTAL , 
	to_timestamp( src.DATATIME ,'YYYY-DD-MM-HH24-SS'), 
	to_timestamp( src.BUSINESS_DT ,'YYYY-DD-MM-HH24-SS'), 
	src.NEW_FIELD
FROM CHANGE.OPER_CHANGE_LOAD src
;


--select count(*) from CHANGE.OPER_CHANGE_LOAD_N;

--select * from CHANGE.OPER_CHANGE_LOAD_N;


--select to_timestamp(BUSINESS_DT,'MM-DD-YYYY-HH24-MI-') from CHANGE.OPER_CHANGE_LOAD_N;


-- 4  History download  file metadata

INSERT INTO CHANGE.ETL_FILE_LOAD(
	SOURCE ,
	FILE_NAME ,
	BUSINESS_DT, 
	LOAD_TS
) 
SELECT	DISTINCT
	'KAFKA' AS SOURCE ,
	'CH_OPER' AS FILE_NAME ,
	ocl.BUSINESS_DT ,
	GETDATE() as LOAD_TS
FROM CHANGE.OPER_CHANGE_LOAD_N ocl
	LEFT JOIN CHANGE.ETL_FILE_LOAD fl
		ON fl.SOURCE = 'KAFKA'
			AND fl.FILE_NAME = 'CH_OPER'
			AND fl.BUSINESS_DT = ocl.BUSINESS_DT			
WHERE fl.FILE_ID IS NULL		
;


-- 5 Create ODS table

--drop table CHANGE.ODS_OPER;

CREATE TABLE IF NOT EXISTS CHANGE.ODS_OPER (
	FILE_ID INTEGER NOT NULL, 
	LOAD_TS TIMESTAMP NOT NULL, 
	BUSINESS_DT DATETIME NOT NULL,
	DATATIME DATE NOT NULL,
	BRANCH VARCHAR NOT NULL,
	CURRENCY VARCHAR NOT NULL,
	AMOUNT INTEGER,
	TOTAL NUMERIC(20,5),
	PRIMARY KEY (TOTAL, DATATIME,AMOUNT,BRANCH) ENABLED 
)
ORDER BY 
	DATATIME, 
	BRANCH,
	AMOUNT,
	TOTAL 
SEGMENTED BY HASH(DATATIME, BRANCH) ALL NODES
PARTITION BY DATATIME GROUP BY CALENDAR_HIERARCHY_DAY(DATATIME, 1, 2)
;


--drop view CHANGE.V_OPER_CHANGE_LOAD_N_ODS_OPER ;

--6   Create view change 

CREATE OR REPLACE VIEW CHANGE.V_OPER_CHANGE_LOAD_N_ODS_OPER AS
SELECT 
	fl.FILE_ID , 
	fl.LOAD_TS ,
	ocl.BUSINESS_DT,
	ocl.DATATIME,
	ocl.BRANCH , 
	ocl.CURRENCY , 
	ocl.AMOUNT,
	ocl.TOTAL
FROM CHANGE.OPER_CHANGE_LOAD_N ocl
	INNER JOIN ( 
		SELECT 
			FILE_ID , 
			LOAD_TS ,
			SOURCE ,
			FILE_NAME ,
			BUSINESS_DT
		FROM CHANGE.ETL_FILE_LOAD 
		LIMIT 1 OVER (PARTITION BY SOURCE, FILE_NAME, BUSINESS_DT ORDER BY LOAD_TS DESC)
		) fl
			ON fl.SOURCE = 'KAFKA'
				AND fl.FILE_NAME = 'CH_OPER'
				AND fl.BUSINESS_DT = ocl.BUSINESS_DT
	LEFT JOIN CHANGE.ODS_OPER trg 
		ON fl.FILE_ID = trg.FILE_ID
			AND ocl.BUSINESS_DT = trg.BUSINESS_DT
			AND ocl.DATATIME = trg.DATATIME
			AND ocl.BRANCH = trg.BRANCH
WHERE trg.FILE_ID IS NULL
;



--7. Insert to ODS table

INSERT INTO CHANGE.ODS_OPER ( 
	FILE_ID , 
	LOAD_TS ,
	BUSINESS_DT , 
	DATATIME , 
	BRANCH ,  
	CURRENCY , 
	AMOUNT,
	TOTAL 
) 
SELECT 
	src.FILE_ID , 
	src.LOAD_TS ,
	src.BUSINESS_DT , 
	src.DATATIME , 
	src.BRANCH , 
	src.CURRENCY , 
	src.AMOUNT,
	src.TOTAL
FROM CHANGE.V_OPER_CHANGE_LOAD_N_ODS_OPER src
;


--drop table CHANGE.DDS_HUB_PRODUCT;

-- 8 Create DDS HUB table

CREATE TABLE IF NOT EXISTS CHANGE.DDS_HUB_PRODUCT (
	HK_BRANCH INTEGER NOT NULL,
	FILE_ID INTEGER NOT NULL, 
	LOAD_TS TIMESTAMP NOT NULL,
	BRANCH VARCHAR NOT NULL,
	CURRENCY VARCHAR NOT NULL,
	AMOUNT INTEGER NOT NULL,
	TOTAL VARCHAR NOT NULL,
	PRIMARY KEY (HK_BRANCH,LOAD_TS,BRANCH) ENABLED
) 
ORDER BY HK_BRANCH,LOAD_TS,BRANCH
SEGMENTED BY HK_BRANCH ALL NODES
;



-- 9 Create VIEW to populate HUB table

drop view CHANGE.V_STG_OPER_DDS_HUB_PRODUCT;
CREATE OR REPLACE VIEW CHANGE.V_STG_OPER_DDS_HUB_PRODUCT AS
SELECT DISTINCT
	HASH(src.BRANCH,src.AMOUNT,src.TOTAL,src.CURRENCY) AS HK_BRANCH ,
	fl.FILE_ID , 
	fl.LOAD_TS , 
	src.BRANCH,
	src.CURRENCY,
	src.AMOUNT,
	src.TOTAL
FROM CHANGE.ODS_OPER src
	INNER JOIN ( 
		SELECT 
			FILE_ID , 
			LOAD_TS ,
			SOURCE ,
			FILE_NAME ,
			BUSINESS_DT
		FROM CHANGE.ETL_FILE_LOAD 
		LIMIT 1 OVER (PARTITION BY SOURCE, FILE_NAME, BUSINESS_DT ORDER BY LOAD_TS DESC)
		) fl
			ON fl.SOURCE = 'KAFKA'
				AND fl.FILE_NAME = 'CH_OPER'
				AND fl.BUSINESS_DT = src.BUSINESS_DT
	LEFT JOIN CHANGE.DDS_HUB_PRODUCT trg 
		ON HASH(src.BRANCH,src.AMOUNT,src.TOTAL,src.CURRENCY) = trg.HK_BRANCH		
WHERE trg.HK_BRANCH IS NULL
;



-- 10  Insert to  HUB table from view

INSERT INTO CHANGE.DDS_HUB_PRODUCT ( 
	HK_BRANCH ,
	FILE_ID , 
	LOAD_TS ,
	BRANCH,
	CURRENCY,
	AMOUNT,
	TOTAL
) 
SELECT 
	src.HK_BRANCH ,
	src.FILE_ID , 
	src.LOAD_TS ,
	src.BRANCH,
	src.CURRENCY,
	src.AMOUNT,
	src.TOTAL 
FROM CHANGE.V_STG_OPER_DDS_HUB_PRODUCT src
;



-- 11  Create DDS SATELLITE table

--drop table CHANGE.DDS_ST_PRODUCT_METRICS;


CREATE TABLE IF NOT EXISTS CHANGE.DDS_ST_PRODUCT_METRICS (
	HK_BRANCH INTEGER NOT NULL,
	FILE_ID INTEGER NOT NULL, 
	LOAD_TS TIMESTAMP NOT NULL,
	HASHDIFF INTEGER NOT NULL,
	DATATIME DATETIME NOT NULL,
	CURRENCY VARCHAR NOT NULL,
	AMOUNT INTEGER NOT NULL,
	TOTAL VARCHAR NOT NULL,
	PRIMARY KEY (HK_BRANCH, HASHDIFF) ENABLED
) 
ORDER BY 
	HK_BRANCH ,
	LOAD_TS
SEGMENTED BY HK_BRANCH ALL NODES
--PARTITION BY DATATIME GROUP BY CALENDAR_HIERARCHY_DAY(DATATIME, 1, 2)
;



-- 12 Create VIEW to metric SATELLITE table

CREATE OR REPLACE VIEW CHANGE.V_STG_OPER_DDS_ST_PRODUCT_METRICS AS
SELECT
	HASH(src.BRANCH,src.AMOUNT,src.TOTAL,src.CURRENCY) AS HK_BRANCH ,
	fl.FILE_ID , 
	fl.LOAD_TS ,
	HASH(src.DATATIME,src.AMOUNT,src.TOTAL) AS HASHDIFF ,
	src.DATATIME ,
	src.CURRENCY ,
	src.AMOUNT,
	src.TOTAL
FROM CHANGE.ODS_OPER src
	INNER JOIN ( 
		SELECT 
			FILE_ID , 
			LOAD_TS ,
			SOURCE ,
			FILE_NAME ,
			BUSINESS_DT
		FROM CHANGE.ETL_FILE_LOAD 
		LIMIT 1 OVER (PARTITION BY SOURCE, FILE_NAME, BUSINESS_DT ORDER BY LOAD_TS DESC)
		) fl
			ON fl.SOURCE = 'KAFKA'
				AND fl.FILE_NAME = 'CH_OPER'
				AND fl.BUSINESS_DT = src.BUSINESS_DT
	LEFT JOIN CHANGE.DDS_ST_PRODUCT_METRICS trg 
		ON HASH(src.BRANCH,src.AMOUNT,src.TOTAL,src.CURRENCY) = trg.HK_BRANCH	
			AND HASH(src.DATATIME,src.AMOUNT,src.TOTAL) = trg.HASHDIFF
WHERE trg.HK_BRANCH IS NULL
;


-- 13  Insert to table from view
--drop table CHANGE.DDS_ST_PRODUCT_METRICS ;

INSERT INTO CHANGE.DDS_ST_PRODUCT_METRICS ( 
	HK_BRANCH ,
	FILE_ID , 
	LOAD_TS ,
	HASHDIFF ,
	DATATIME ,
	CURRENCY ,
	AMOUNT,
	TOTAL
	
)
SELECT 
	src.HK_BRANCH ,
	src.FILE_ID , 
	src.LOAD_TS ,
	src.HASHDIFF ,
	src.DATATIME ,
	src.CURRENCY ,
	src.AMOUNT,
	src.TOTAL
FROM CHANGE.V_STG_OPER_DDS_ST_PRODUCT_METRICS src
;


--  14  Create view to get actual data

create schema OPERSVOD_STG;
--drop view OPERSVOD_STG.V_DDS_OPER;

CREATE OR REPLACE VIEW OPERSVOD_STG.V_DDS_OPER AS
SELECT 
	hub.BRANCH,
	st.DATATIME,
	hub.CURRENCY,
	hub.AMOUNT,
	hub.TOTAL
FROM CHANGE.DDS_HUB_PRODUCT hub
	INNER JOIN CHANGE.DDS_ST_PRODUCT_METRICS st
		ON hub.HK_BRANCH = st.HK_BRANCH
LIMIT 1 OVER (PARTITION BY BRANCH, DATATIME ORDER BY st.LOAD_TS DESC)
;


--test data 
SELECT 
	hub.BRANCH,
	st.DATATIME,
	hub.CURRENCY,
	hub.AMOUNT,
	hub.TOTAL
FROM CHANGE.DDS_HUB_PRODUCT hub
	INNER JOIN CHANGE.DDS_ST_PRODUCT_METRICS st
		ON hub.HK_BRANCH = st.HK_BRANCH;
		



-- 15  New  MART on actual data (4 fields)

SELECT
	BRANCH ,
	DATE_TRUNC('MONTH', DATATIME)::DATE AS MONTH,
	avg(AMOUNT) AS AVG_AMOUNT,
	avg(TOTAL) AS AVG_TOTAL
FROM OPERSVOD_STG.V_DDS_OPER
GROUP BY 
	BRANCH ,
	DATE_TRUNC('MONTH', DATATIME)::DATE
;	



---------------------------------------------------------

--15   Now get new FILE with new data and 1 more fields added: NEW_FIELD


INSERT INTO CHANGE.ETL_FILE_LOAD(
	SOURCE ,
	FILE_NAME ,
	BUSINESS_DT, 
	LOAD_TS
) 
SELECT	DISTINCT
	'KAFKA' AS SOURCE ,
	'CH_OPER' AS FILE_NAME ,
	ocl.BUSINESS_DT, 
	GETDATE() as LOAD_TS
FROM CHANGE.OPER_CHANGE_LOAD_N ocl
	LEFT JOIN CHANGE.ETL_FILE_LOAD fl
		ON fl.SOURCE = 'KAFKA'
			AND fl.FILE_NAME = 'CH_OPER'
			AND fl.BUSINESS_DT = ocl.BUSINESS_DT			
WHERE fl.FILE_ID IS NULL		
;


--16   Create DDS SATELLITE TABLE FOR NEW ATTRIBUTES

--drop table CHANGE.DDS_ST_PRODUCT_METRICS_NEW;

CREATE TABLE IF NOT EXISTS CHANGE.DDS_ST_PRODUCT_METRICS_NEW (
	HK_BRANCH INTEGER NOT NULL,
	FILE_ID INTEGER NOT NULL, 
	LOAD_TS TIMESTAMP NOT NULL,
	HASHDIFF INTEGER NOT NULL,
	DATATIME DATE NOT NULL,
	CURRENCY VARCHAR NOT NULL,
	AMOUNT INTEGER,
	TOTAL NUMERIC(20,5),
	NEW_FIELD NUMERIC(3,0),   -- add new field
	PRIMARY KEY (HK_BRANCH, HASHDIFF) ENABLED
) 
ORDER BY 
	HK_BRANCH ,
	LOAD_TS
SEGMENTED BY HK_BRANCH ALL NODES
PARTITION BY DATATIME GROUP BY CALENDAR_HIERARCHY_DAY(DATATIME, 1, 2)
;



--drop view CHANGE.V_STG_OPER_DDS_ST_PRODUCT_METRICS_NEW;
-- 17.   Create VIEW to view SATELLITE table

CREATE OR REPLACE VIEW CHANGE.V_STG_OPER_DDS_ST_PRODUCT_METRICS_NEW AS
SELECT
	HASH(src.BRANCH,src.AMOUNT,src.TOTAL,src.CURRENCY) AS HK_BRANCH ,
	fl.FILE_ID , 
	fl.LOAD_TS ,
	HASH(src.DATATIME,src.AMOUNT,src.TOTAL) AS HASHDIFF ,
	src.DATATIME,
	src.CURRENCY ,
	src.AMOUNT,
	src.TOTAL,
	src.NEW_FIELD
FROM CHANGE.OPER_CHANGE_LOAD_N src
	INNER JOIN ( 
		SELECT 
			FILE_ID , 
			LOAD_TS ,
			SOURCE ,
			FILE_NAME ,
			BUSINESS_DT
		FROM CHANGE.ETL_FILE_LOAD 
		LIMIT 1 OVER (PARTITION BY SOURCE, FILE_NAME, BUSINESS_DT ORDER BY LOAD_TS DESC)
		) fl
			ON fl.SOURCE = 'KAFKA'
				AND fl.FILE_NAME = 'CH_OPER'
				AND fl.BUSINESS_DT = src.BUSINESS_DT
	LEFT JOIN CHANGE.DDS_ST_PRODUCT_METRICS_NEW trg 
		ON HASH(src.BRANCH,src.AMOUNT,src.TOTAL,src.CURRENCY) = trg.HK_BRANCH	
			AND HASH(src.DATATIME,src.AMOUNT,src.TOTAL) = trg.HASHDIFF
WHERE trg.HK_BRANCH IS NULL
;



--18  Insert to SATELLITE table
--drop table CHANGE.DDS_ST_PRODUCT_METRICS_NEW;

INSERT INTO CHANGE.DDS_ST_PRODUCT_METRICS_NEW ( 
	HK_BRANCH ,
	FILE_ID , 
	LOAD_TS ,
	HASHDIFF ,
	DATATIME ,
	CURRENCY ,
	AMOUNT,
	TOTAL,
	NEW_FIELD
)
SELECT 
	src.HK_BRANCH ,
	src.FILE_ID , 
	src.LOAD_TS ,
	src.HASHDIFF ,
	src.DATATIME ,
	src.CURRENCY ,
	src.AMOUNT,
	src.TOTAL,
	src.NEW_FIELD
FROM CHANGE.V_STG_OPER_DDS_ST_PRODUCT_METRICS_NEW src
;

--19  NEW VIEW to get actual data


CREATE OR REPLACE VIEW OPERSVOD_STG.V_DDS_OPER_NEW AS
SELECT 
	hub.BRANCH ,
	st1.FILE_ID , 
	st1.LOAD_TS ,
	st1.HASHDIFF ,
	st1.DATATIME ,
	st1.CURRENCY ,
	st1.AMOUNT,
	st1.TOTAL,
	st2.NEW_FIELD
FROM CHANGE.DDS_HUB_PRODUCT hub
	INNER JOIN CHANGE.DDS_ST_PRODUCT_METRICS st1
		ON hub.HK_BRANCH = st1.HK_BRANCH
	INNER JOIN CHANGE.DDS_ST_PRODUCT_METRICS_NEW st2
		ON hub.HK_BRANCH = st2.HK_BRANCH
WHERE st1.DATATIME = st2.DATATIME
LIMIT 1 OVER (PARTITION BY hub.BRANCH, st1.DATATIME ORDER BY st1.LOAD_TS DESC)
;


-- test

SELECT 
	hub.BRANCH ,
	st1.FILE_ID , 
	st1.LOAD_TS ,
	st1.HASHDIFF ,
	st1.DATATIME ,
	st1.CURRENCY ,
	st1.AMOUNT,
	st1.TOTAL,
	st2.NEW_FIELD
FROM CHANGE.DDS_HUB_PRODUCT hub
INNER JOIN CHANGE.DDS_ST_PRODUCT_METRICS st1
		ON hub.HK_BRANCH = st1.HK_BRANCH
	INNER JOIN CHANGE.DDS_ST_PRODUCT_METRICS_NEW st2
		ON hub.HK_BRANCH = st2.HK_BRANCH;


--  20  New  MART on actual data + add new field : NEW_FIELD

SELECT
	BRANCH,
	DATE_TRUNC('MONTH', DATATIME)::DATE AS MNTH,
	avg(AMOUNT) AS AVG_AMOUNT,
	avg(TOTAL) AS AVG_TOTAL,
	avg(NEW_FIELD) AS AVG_NEW_FIELD
FROM OPERSVOD_STG.V_DDS_OPER_NEW
GROUP BY 
	BRANCH ,
	DATE_TRUNC('MONTH', DATATIME);
